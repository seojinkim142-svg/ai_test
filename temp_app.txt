import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import ActionsPanel from "./components/ActionsPanel";
import FileUpload from "./components/FileUpload";
import Header from "./components/Header";
import PdfPreview from "./components/PdfPreview";
import QuizSection from "./components/QuizSection";
import SummaryCard from "./components/SummaryCard";
import { generateQuiz, generateSummary } from "./services/openai";
import { extractPdfText, generatePdfThumbnail } from "./utils/pdf";

function App() {
  const [file, setFile] = useState(null);
  const [extractedText, setExtractedText] = useState("");
  const [previewText, setPreviewText] = useState("");
  const [pageInfo, setPageInfo] = useState({ used: 0, total: 0 });
  const [pdfUrl, setPdfUrl] = useState(null);
  const [status, setStatus] = useState("");
  const [error, setError] = useState("");
  const [isLoadingText, setIsLoadingText] = useState(false);
  const [isLoadingQuiz, setIsLoadingQuiz] = useState(false);
  const [isLoadingSummary, setIsLoadingSummary] = useState(false);
  const [questions, setQuestions] = useState(null);
  const [summary, setSummary] = useState("");
  const [selectedChoices, setSelectedChoices] = useState({});
  const [revealedChoices, setRevealedChoices] = useState({});
  const [shortAnswerInput, setShortAnswerInput] = useState("");
  const [shortAnswerResult, setShortAnswerResult] = useState(null);
  const [thumbnailUrl, setThumbnailUrl] = useState(null);
  const [uploadedFiles, setUploadedFiles] = useState([]);
  const [selectedFileId, setSelectedFileId] = useState(null);
  const [panelTab, setPanelTab] = useState("summary");
  const [splitPercent, setSplitPercent] = useState(50);
  const summaryRequestedRef = useRef(false);
  const quizRequestedRef = useRef(false);
  const isDraggingRef = useRef(false);
  const detailContainerRef = useRef(null);

  const shortPreview = useMemo(
    () => (previewText.length > 700 ? `${previewText.slice(0, 700)}...` : previewText),
    [previewText]
  );

  useEffect(() => {
    return () => {
      if (pdfUrl) {
        URL.revokeObjectURL(pdfUrl);
      }
    };
  }, [pdfUrl]);

  const resetQuizState = () => {
    setQuestions(null);
    setSelectedChoices({});
    setRevealedChoices({});
    setShortAnswerInput("");
    setShortAnswerResult(null);
  };

  const processSelectedFile = useCallback(
    async (item, { pushState = true } = {}) => {
      if (!item?.file) return;
      const targetFile = item.file;

      if (pushState && selectedFileId !== item.id) {
        window.history.pushState({ view: "detail", fileId: item.id }, "", window.location.pathname);
      }

      if (pdfUrl) {
        URL.revokeObjectURL(pdfUrl);
      }
      setPdfUrl(URL.createObjectURL(targetFile));
      setFile(targetFile);
      setSelectedFileId(item.id);
      resetQuizState();
      summaryRequestedRef.current = false;
      quizRequestedRef.current = false;
      setError("");
      setSummary("");
      setLayout(null);
      setHighlights([]);
      setStatus("PDF ?ìŠ¤??ì¶”ì¶œ ì¤‘ì…?ˆë‹¤...");
      setIsLoadingText(true);
      setThumbnailUrl(null);

      try {
        const [textResult, thumb] = await Promise.all([extractPdfText(targetFile), generatePdfThumbnail(targetFile)]);
        const { text, pagesUsed, totalPages, layout: pageLayout } = textResult;
        setExtractedText(text);
        setPreviewText(text);
        setPageInfo({ used: pagesUsed, total: totalPages });
        setLayout(pageLayout);
        setThumbnailUrl(thumb);
        setStatus(`ì¶”ì¶œ ?„ë£Œ (?¬ìš© ?˜ì´ì§€: ${pagesUsed}/${totalPages})`);
      } catch (err) {
        setError(`PDF ì¶”ì¶œ???¤íŒ¨?ˆìŠµ?ˆë‹¤: ${err.message}`);
        setExtractedText("");
        setPreviewText("");
        setPageInfo({ used: 0, total: 0 });
        setLayout(null);
      } finally {
        setIsLoadingText(false);
      }
    },
    [pdfUrl, selectedFileId]
  );

  const handleFileChange = async (event) => {
    const files = Array.from(event.target.files || []);
    if (!files.length) return;

    const withThumbs = await Promise.all(
      files.map(async (f) => {
        const thumb = await generatePdfThumbnail(f);
        return {
          id: `${f.name}-${f.lastModified}-${Math.random().toString(16).slice(2)}`,
          file: f,
          name: f.name,
          size: f.size,
          thumbnail: thumb,
        };
      })
    );

    setUploadedFiles((prev) => [...prev, ...withThumbs]);
    setStatus("?…ë¡œ??ëª©ë¡?ì„œ ?¸ë„¤?¼ì„ ? íƒ???”ì•½/?´ì¦ˆë¥??œì‘?˜ì„¸??");
  };

  const showDetail = Boolean(file && selectedFileId);

  const goBackToList = useCallback(() => {
    if (pdfUrl) {
      URL.revokeObjectURL(pdfUrl);
    }
    setSelectedFileId(null);
    setFile(null);
    setPdfUrl(null);
    setExtractedText("");
    setPreviewText("");
    setPageInfo({ used: 0, total: 0 });
    setSummary("");
    setLayout(null);
    setHighlights([]);
    setPanelTab("summary");
    summaryRequestedRef.current = false;
    quizRequestedRef.current = false;
    resetQuizState();
    setStatus("?…ë¡œ??ëª©ë¡?ì„œ ?¸ë„¤?¼ì„ ? íƒ???”ì•½/?´ì¦ˆë¥??œì‘?˜ì„¸??");
  }, [pdfUrl]);
  const uploadedFilesRef = useRef(uploadedFiles);
  const goBackToListRef = useRef(goBackToList);
  const processSelectedFileRef = useRef(processSelectedFile);

  useEffect(() => {
    uploadedFilesRef.current = uploadedFiles;
  }, [uploadedFiles]);

  useEffect(() => {
    goBackToListRef.current = goBackToList;
  }, [goBackToList]);

  useEffect(() => {
    processSelectedFileRef.current = processSelectedFile;
  }, [processSelectedFile]);

  useEffect(() => {
    const handleMouseMove = (event) => {
      if (!isDraggingRef.current) return;
      const container = detailContainerRef.current;
      if (!container) return;
      const rect = container.getBoundingClientRect();
      const percent = ((event.clientX - rect.left) / rect.width) * 100;
      const clamped = Math.min(75, Math.max(25, percent));
      setSplitPercent(clamped);
    };

    const handleMouseUp = () => {
      if (!isDraggingRef.current) return;
      isDraggingRef.current = false;
      document.body.style.userSelect = "";
    };

    window.addEventListener("mousemove", handleMouseMove);
    window.addEventListener("mouseup", handleMouseUp);
    return () => {
      window.removeEventListener("mousemove", handleMouseMove);
      window.removeEventListener("mouseup", handleMouseUp);
    };
  }, []);

  useEffect(() => {
    window.history.replaceState({ view: "list" }, "", window.location.pathname);

    const handlePopState = (event) => {
      const state = event.state;
      if (state?.view === "detail" && state.fileId) {
        const target = uploadedFilesRef.current.find((f) => f.id === state.fileId);
        if (target) {
          processSelectedFileRef.current(target, { pushState: false });
          return;
        }
      }
      goBackToListRef.current();
    };

    window.addEventListener("popstate", handlePopState);
    return () => window.removeEventListener("popstate", handlePopState);
  }, []);

  const handleDragStart = () => {
    isDraggingRef.current = true;
    document.body.style.userSelect = "none";
  };

  const splitStyle = {
    flexBasis: `${splitPercent}%`,
    flexShrink: 0,
    minWidth: "25%",
    maxWidth: "75%",
  };

  const mapSentenceToRect = useCallback(
    (sentence) => {
      if (!layout?.pages?.length || !sentence) return null;
      const cleaned = sentence.replace(/["'?œâ€â€˜â€?+/g, "").trim();
      const targets = [
        cleaned,
        cleaned.replace(/\s+/g, " "),
      ].filter(Boolean);

      for (const page of layout.pages) {
        let idx = -1;
        let targetLen = 0;
        for (const t of targets) {
          const found = page.text.toLowerCase().indexOf(t.toLowerCase());
          if (found !== -1) {
            idx = found;
            targetLen = t.length;
            break;
          }
        }
        if (idx === -1) continue;
        const endIdx = idx + targetLen;
        const items = page.items.filter((it) => it.end > idx && it.start < endIdx);
        if (!items.length) continue;
        const minX = Math.min(...items.map((it) => it.rect.x));
        const minY = Math.min(...items.map((it) => it.rect.y));
        const maxX = Math.max(...items.map((it) => it.rect.x + it.rect.width));
        const maxY = Math.max(...items.map((it) => it.rect.y + it.rect.height));
        return {
          page: page.pageNumber,
          rect: {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY,
          },
          sentence,
        };
      }
      return null;
    },
    [layout]
  );

  const requestQuestions = async () => {
    if (isLoadingQuiz || quizRequestedRef.current) return;
    if (!file) {
      setError("ë¨¼ì? PDFë¥??…ë¡œ?œí•´ì£¼ì„¸??");
      return;
    }

    if (!extractedText) {
      setError("PDF ?ìŠ¤?¸ê? ?„ì§ ì¤€ë¹„ë˜ì§€ ?Šì•˜?µë‹ˆ?? ? ì‹œ ?„ì— ?œë„?´ì£¼?¸ìš”.");
      return;
    }

    quizRequestedRef.current = true;
    setIsLoadingQuiz(true);
    setError("");
    setStatus("ë¬¸ì œ ?¸íŠ¸ë¥??ì„±?˜ëŠ” ì¤‘ì…?ˆë‹¤...");

    try {
      const quiz = await generateQuiz(extractedText);
      setQuestions(quiz);
      setSelectedChoices({});
      setRevealedChoices({});
      setShortAnswerInput("");
      setShortAnswerResult(null);
      setStatus("ë¬¸ì œ ?¸íŠ¸ ?ì„± ?„ë£Œ!");
    } catch (err) {
      setError(`ë¬¸ì œ ?ì„±???¤íŒ¨?ˆìŠµ?ˆë‹¤: ${err.message}`);
    } finally {
      setIsLoadingQuiz(false);
    }
  };

  const handleChoiceSelect = (qIdx, choiceIdx) => {
    setSelectedChoices((prev) => ({ ...prev, [qIdx]: choiceIdx }));
    setRevealedChoices((prev) => ({ ...prev, [qIdx]: true }));
  };

  const handleShortAnswerCheck = () => {
    if (!questions?.shortAnswer?.answer) return;
    const user = shortAnswerInput.trim().toLowerCase();
    const answer = String(questions.shortAnswer.answer).trim().toLowerCase();
    const normalizedUser = user.replace(/\s+/g, "");
    const normalizedAnswer = answer.replace(/\s+/g, "");
    const isCorrect = normalizedUser === normalizedAnswer;
    setShortAnswerResult({
      isCorrect,
      answer: questions.shortAnswer.answer,
    });
  };

  const requestSummary = async () => {
    if (isLoadingSummary || summaryRequestedRef.current) return;
    if (!file) {
      setError("ë¨¼ì? PDFë¥??…ë¡œ?œí•´ì£¼ì„¸??");
      return;
    }
    if (!extractedText) {
      setError("PDF ?ìŠ¤?¸ê? ?„ì§ ì¤€ë¹„ë˜ì§€ ?Šì•˜?µë‹ˆ?? ? ì‹œ ?„ì— ?œë„?´ì£¼?¸ìš”.");
      return;
    }

    summaryRequestedRef.current = true;
    setIsLoadingSummary(true);
    setError("");
    setStatus("?”ì•½???ì„±?˜ëŠ” ì¤‘ì…?ˆë‹¤...");
    try {
      const summarized = await generateSummary(extractedText);
      setSummary(summarized);
      setStatus("?”ì•½ ?ì„± ?„ë£Œ!");
    } catch (err) {
      setError(`?”ì•½ ?ì„±???¤íŒ¨?ˆìŠµ?ˆë‹¤: ${err.message}`);
      setStatus("");
    } finally {
      setIsLoadingSummary(false);
    }
  };

  const requestHighlights = async () => {
    if (isLoadingHighlights) return;
    if (!layout?.pages?.length) {
      setError("PDF ?ˆì´?„ì›ƒ ?•ë³´ë¥?ë¶ˆëŸ¬?¤ì? ëª»í–ˆ?µë‹ˆ?? ?Œì¼???¤ì‹œ ?…ë¡œ?œí•´ì£¼ì„¸??");
      return;
    }
    if (!extractedText) return;

    setIsLoadingHighlights(true);
    try {
      const data = await generateHighlights(extractedText);
      const mapped =
        data?.highlights
          ?.map((h) => mapSentenceToRect(h.sentence))
          .filter(Boolean) || [];
      setHighlights(mapped);
    } catch (err) {
      setError(`?˜ì´?¼ì´???ì„±???¤íŒ¨?ˆìŠµ?ˆë‹¤: ${err.message}`);
    } finally {
      setIsLoadingHighlights(false);
    }
  };

  const canAutoRequest = useCallback(() => file && extractedText && !isLoadingText, [file, extractedText, isLoadingText]);

  // ?Œì¼??? íƒ?˜ê³  ?ìŠ¤?¸ê? ì¤€ë¹„ë˜ë©??”ì•½???ë™?¼ë¡œ ?”ì²­
  useEffect(() => {
    if (
      canAutoRequest() &&
      !summary &&
      !isLoadingSummary &&
      !summaryRequestedRef.current
    ) {
      requestSummary();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [canAutoRequest, summary, isLoadingSummary]);

  useEffect(() => {
    if (
      summary &&
      canAutoRequest() &&
      !questions &&
      !isLoadingQuiz &&
      !quizRequestedRef.current
    ) {
      requestQuestions();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [summary, canAutoRequest, questions, isLoadingQuiz]);

  useEffect(() => {
    if (summary && layout && !highlights.length && !isLoadingHighlights) {
      requestHighlights();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [summary, layout, highlights.length, isLoadingHighlights]);

  const renderStartPage = () => (
    <section className="grid grid-cols-1 gap-4">
      <FileUpload
        file={file}
        pageInfo={pageInfo}
        isLoadingText={isLoadingText}
        thumbnailUrl={thumbnailUrl}
        uploadedFiles={uploadedFiles}
        onSelectFile={processSelectedFile}
        onFileChange={handleFileChange}
        selectedFileId={selectedFileId}
      />
    </section>
  );

  const renderDetailPage = () => (
    <section
      ref={detailContainerRef}
      className="flex flex-col gap-4 lg:h-[clamp(70vh,calc(100vh-120px),90vh)] lg:flex-row lg:items-stretch lg:overflow-hidden"
    >
      <div className="flex flex-col gap-3 lg:h-full lg:overflow-y-auto" style={splitStyle}>
        <PdfPreview pdfUrl={pdfUrl} file={file} pageInfo={pageInfo} highlights={highlights} />
      </div>

      <div className="hidden w-2 cursor-col-resize items-stretch justify-center lg:flex">
        <div
          className="h-full w-1 rounded-full bg-white/10 transition hover:bg-white/30"
          onMouseDown={handleDragStart}
          role="separator"
          aria-label="?¨ë„ ?¬ê¸° ì¡°ì ˆ"
        />
      </div>

      <div className="flex flex-col gap-4 lg:min-w-0 lg:flex-1 lg:h-full lg:max-h-full lg:overflow-hidden">
        <div className="flex gap-2 rounded-2xl border border-white/10 bg-slate-900/80 px-3 py-2 shadow-lg shadow-black/30 lg:sticky lg:top-0 lg:z-10 lg:backdrop-blur">
          {[
            { id: "summary", label: "?”ì•½" },
            { id: "quiz", label: "?´ì¦ˆ" },
          ].map((tab) => {
            const active = panelTab === tab.id;
            return (
              <button
                key={tab.id}
                type="button"
                onClick={() => setPanelTab(tab.id)}
                className={`rounded-full border px-3 py-1 text-sm font-semibold transition ${
                  active
                    ? "border-emerald-300/60 bg-emerald-400/15 text-emerald-100"
                    : "border-white/15 bg-white/5 text-slate-200 hover:border-emerald-200/40 hover:text-emerald-100"
                }`}
              >
                {tab.label}
              </button>
            );
          })}
        </div>

        <div className="flex-1 overflow-auto pr-1 pb-1">
          {panelTab === "summary" && (
            <div className="rounded-3xl border border-white/5 bg-slate-900/70 p-4 shadow-lg shadow-black/30">
              <p className="text-sm font-semibold text-emerald-200">?”ì•½</p>
              {isLoadingSummary && <p className="mt-2 text-sm text-slate-300">?”ì•½ ?ì„± ì¤?..</p>}
              {!isLoadingSummary && summary && <SummaryCard summary={summary} />}
              {!isLoadingSummary && !summary && <p className="mt-2 text-sm text-slate-400">?”ì•½??ì¤€ë¹„ë˜ë©??œì‹œ?©ë‹ˆ??</p>}
            </div>
          )}

          {panelTab === "quiz" && (
            <>
              <ActionsPanel
                title="?´ì¦ˆ ?ì„±"
                stepLabel="?´ì¦ˆ"
                hideSummary
                hideQuiz
                isLoadingQuiz={isLoadingQuiz}
                isLoadingSummary={isLoadingSummary}
                isLoadingText={isLoadingText}
                status={status}
                error={error}
                shortPreview={shortPreview}
                onRequestQuiz={requestQuestions}
                onRequestSummary={requestSummary}
              />

              {questions && (
                <QuizSection
                  questions={questions}
                  summary={null}
                  selectedChoices={selectedChoices}
                  revealedChoices={revealedChoices}
                  shortAnswerInput={shortAnswerInput}
                  shortAnswerResult={shortAnswerResult}
                  onSelectChoice={handleChoiceSelect}
                  onShortAnswerChange={setShortAnswerInput}
                  onShortAnswerCheck={handleShortAnswerCheck}
                />
              )}
            </>
          )}
        </div>
      </div>
    </section>
  );

  return (
    <div className="relative min-h-screen overflow-hidden text-slate-100">
      <div className="pointer-events-none absolute inset-0">
        <div className="absolute -left-32 top-10 h-72 w-72 rounded-full bg-emerald-500/20 blur-3xl" />
        <div className="absolute right-[-80px] top-32 h-80 w-80 rounded-full bg-cyan-500/10 blur-3xl" />
        <div className="absolute bottom-[-120px] left-1/2 h-96 w-96 -translate-x-1/2 rounded-full bg-indigo-500/10 blur-3xl" />
      </div>

      <main className="relative z-10 mx-auto flex w-full max-w-none flex-col gap-4 py-4">
        <Header />
        <div className="px-0">
          {!showDetail && renderStartPage()}
          {showDetail && renderDetailPage()}
        </div>
      </main>
    </div>
  );
}

export default App;
